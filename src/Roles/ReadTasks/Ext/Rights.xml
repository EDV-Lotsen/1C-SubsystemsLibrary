<?xml version="1.0" encoding="UTF-8"?>
<Rights xmlns="http://v8.1c.ru/8.2/roles" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Rights" version="2.3">
	<setForNewObjects>false</setForNewObjects>
	<setForAttributesByDefault>true</setForAttributesByDefault>
	<independentRightsOfChildObjects>false</independentRightsOfChildObjects>
	<object>
		<name>Task.PerformerTask.Command.Completed</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Report.ExpiringTasksOnDate</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#ByValuesAndSetsAdvanced( "Task.PerformerTask", "", "",
"",
""",
"Object","T.BusinessProcess","OR",
"Users","T.Author","OR",
"Users","T.Performer","OR",
"Users","T.TaskPerformerGroup","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")

</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.TaskPerformers</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.PerformerRoles</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask.Command.AllTasks</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>CommonCommand.TasksBySubject</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.TaskAddressingObjects</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask.Command.MyTasks</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask.Command.Forward</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Report.Tasks</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<restrictionTemplate>
		<name>ByValuesAndSetsAdvanced</name>
		<condition>// ByValuesAndSetsAdvanced(Table, -, Modifier, JoinedTables, B, A1,F1,B1, A2,F2,B2,..., A(n), F(n), B(n)).
// Parameter #: 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,...,3+n*3,4+n*3,5+n*3.
// Read as: "access restriction by values and sets advanced".
// Parameters:
// Table - The current table name, for example, Document.ProductAndServiceReceipt.
// Modifier - changes the template.
// Modifier 1 - the DontLimitAccessToGroups
// string enables unconditional selection of hierarchical catalog groups.
// Modifier 2 - the AdvancedOR string enables extended check for restrictions
// (for example ByCompanies or ByAccounts) when
// access kind setting option
// in access groups "All allowed, none not allowed" is considered as "Access kind is not used".
// If this modifier is not used then the check result is True,
// and therefore the final result is also True if "All allowed, none not allowed" option is set,
// for at least one access kind (either ByCompanies or ByAccounts).
// Modifier is intended for use only when checking access value sets.
// You can combine modifiers as follows: "DontLimitAccessToGroups" 
// "AdvancedOR",
"DontLimitAccessToGroups,AdvancedOR".
// No other modifiers are available in this version of the template.
// JoinedTables - the text of command used to join the additional tables in the query language such as
// "INNER JOIN Document.AdvanceReport.PaymentToVendor AS T1 On T.Link = T1.Ref".
// Joining allows to define fields of PaymentToVendor table as fields of a main table in order to check
// values of those fields as if they were main table field values.
// The user should keep in mind that when strings multiply as a result of the joining,
// it is enough for any string to satisfy the check condition, so the string check results are joined by "OR".
// O - Leading brackets "(".
// A(n) - Access kind - name of access kind, for example, "Companies". For composite type fields, use can improve performance by 
// specifying multiple names, for example, "Companies,IndividualGroups",
// rather than use several parameter blocks with the same field name.
// Special access kinds "Object", "Condition",
// "RightsSettings", "ReadRight", "EditRight", can be used only separately.
// When A(n) = "Condition" or "", P(n) contains a condition string in the query language, for example,
// "T.Author = &amp;AuthorizedUser", 
// "VALUETYPE(T.Owner) = TYPE(Reference.Company)" where T is alias of current table.
// When A(n) = "ReadRight" OR "EditRight",
// a check is made whether the right to read and write T.P(n) value table is available.
// When A(n) = "Object" or " ", then
// if a record of a right dependency is available in the AccessRightDependencies information register, 
// a check is made whether the right to read T.P(n) and the access value sets (stored in the AccessValueSets information register
// and read by the T.P(n) reference for a read right) is available;
// otherwise the standard rule is used:
// when Right = "Read", a check is made whether the right to read T.P(n) and access value sets (stored in the AccessValueSets information register
// and read by T.P.(n) reference for a read right) is available;
// when Right = "Edit" then a check is made whether
// the right to edit T.P(n) and access value sets read by T.P(n) reference for an edit right is available.
// P(n) - The field of a checked value
// with an alias, for example, "T.Company", except for cases when A(n) = "Condition" or "".
// O(n) - Logical operations "AND", "OR" in combination with brackets "(", ")".
// Note: you can increase the maximum number of field values checked at the same time by
// changing the template, but you must specify all template parameters, i.e. include empty rows
// when the number of fields is below maximum.
// The template has the following structure:
// &lt;Joining by table1&gt; &lt;Joining by table2&gt; ... &lt;Joining by table(m)&gt;
// &lt;Common part of conditions&gt; &lt;Condition by parameter group 1&gt; AND/OR &lt;Condition by parameter group 2&gt; AND/OR ... &lt;Condition by parameter group(n)&gt;
// Example:
// ByValuesAndSetsAdvanced("DocumentJournal.WarehouseDocuments", "", "",
// "",
// "",
// "Object","T.Ref","And",
// "Object","T.MainDocument","", "","","", ...)

// Validating the Right parameter
#If Not ("#Parameter(2)" = "Read" OR "#Parameter(2)" = "Insert" OR
 "#Parameter(2)" = "Update" OR "#Parameter(2)" = "Delete" OR "#Parameter(2)" = "")
 OR #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)" = "Read"
 OR #CurrentAccessRightName = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is invalid, a string is inserted to raise an access restriction assembly error
 InvalidRight: #Parameter(2)
#EndIf

// Validating the modifier parameter TableName
#If "#Parameter(1)" &lt;&gt; #CurrentTypeName #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter
#If Not ( "#Parameter(3)" = "DontLimitAccessToGroups"
 OR "#Parameter(3)" = "AdvancedOR"
 OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR"
 OR "#Parameter(3)" = "") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	InvalidModifier: #Parameter(3)
#EndIf

// Making the general check whether access restrictions are used at
// the record level. Checking whether at least one restriction from the specified access kinds is used.
#If &amp;UseRecordLevelSecurity
 AND Not (True
 AND ("#Parameter(6)" = "" AND "#Parameter(7)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContain(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(6),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),"))
 AND ("#Parameter(9)" = "" AND "#Parameter(10)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(9),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(9),"))
 AND ("#Parameter(12)" = "" AND "#Parameter(13)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(12),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),"))
 AND ("#Parameter(15)" = "" AND "#Parameter(16)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(15),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(15),"))
 AND ("#Parameter(18)" = "" AND "#Parameter(19)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(18),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),"))
 AND ("#Parameter(21)" = "" AND "#Parameter(22)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(21),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(21),"))
 AND ("#Parameter(24)" = "" AND "#Parameter(25)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(24),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),"))
 AND ("#Parameter(27)" = "" AND "#Parameter(28)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(27),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(27),"))
 AND ("#Parameter(30)" = "" AND "#Parameter(31)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(30),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),"))
 AND ("#Parameter(33)" = "" AND "#Parameter(34)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(33),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(33),"))
 AND ("#Parameter(36)" = "" AND "#Parameter(37)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(36),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(36),"))
 AND ("#Parameter(39)" = "" AND "#Parameter(40)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(39),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(39),"))
 AND ("#Parameter(42)" = "" AND "#Parameter(43)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(42),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(42),"))
 AND ("#Parameter(45)" = "" AND "#Parameter(46)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(45),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(45),"))
 AND ("#Parameter(48)" = "" AND "#Parameter(49)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(48),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(48),"))
 AND ("#Parameter(51)" = "" AND "#Parameter(52)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(51),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(51),"))
 ) #Then

T FROM T // T is the current table alias (intentionally shortened in order to minimize the number of characters in the text of the parameter condition in the query language)

// Tables joined to the row of the current table T that is being checked
#Parameter(4)

WHERE

// Unconditional selection of folders in a hierarchical metadata object (if required)
#If "#Parameter(3)" = "DontLimitAccessToGroups" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
	T.IsFolder OR
#EndIf

TRUE IN
(	// Checking user rights for the entire current table.
	// Rights for tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
		Catalog.MetadataObjectIDs AS CurrentTableProperties
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			 (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupTables AS AccessGroupTables
					WHERE
						 AccessGroupTables.Table = CurrentTableProperties.Ref
						AND AccessGroupTables.AccessGroup = AccessGroups.Ref
					#If Not #CurrentAccessRightName = "Read" #Then
						AND AccessGroupTables.Update
					#EndIf
			 )
			AND AccessGroups.Ref IN
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
					ON
						 UserGroupContent.User = &amp;AuthorizedUser
						AND UserGroupContent.UserGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Searching for values of the specified fields in the allowed values of access groups (users)

	#Parameter(5) // [([(][(]...] 0-n opening brackets.

//// Checking the field value of parameter group 1.
#If "#Parameter(6)" = "Condition" OR "#Parameter(6)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	( #Parameter(7) )
#ElsIf "#Parameter(6)" = "ReadRight" OR "#Parameter(6)" = "EditRight" #Then
	 #Parameter(7) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
 
AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(7))
		#If Not "#Parameter(6)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(6)" = "Object" OR "#Parameter(6)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(7))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right. 
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights.
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(7))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(7)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(7)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled.
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(7)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled for the current set
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(7)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(7)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(7)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(7)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
 
UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
 
UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(6)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(6)", ",") #Then
		IncorrectAccessKind: "#Parameter(6)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(6)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),") #Then
	
	 (
			ISNULL(#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(6),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(7)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(7)
		#ElsIf "#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(6)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else 
// Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(7)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(7))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(8) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 2
#If "#Parameter(9)" = "" AND "#Parameter(10)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(9)" = "Condition" OR "#Parameter(9)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(10) )
#ElsIf "#Parameter(9)" = "ReadRight" OR "#Parameter(9)" = "EditRight" #Then
	 #Parameter(10) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
 
AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(10))
		#If Not "#Parameter(9)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(9)" = "Object" OR "#Parameter(9)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(10))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right
				// Edit right can depend on the Read or Edit leading rights.
				AND Not
 
(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
 
AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(10))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(10)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(10)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN
// Not all checks are disabled.
		 (
				SELECT TOP 1 TRUE
// Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(10)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(10)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(10)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting of the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(10)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selection of the first forbidden access value.
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(10)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
 
UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(9)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(9),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(9)", ",") #Then
		IncorrectAccessKind: "#Parameter(9)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(9)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(9),") #Then
	
	 (
			ISNULL(#Parameter(10), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(9),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(9),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(10)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(10)
		#ElsIf "#Parameter(10)" = "T.Ref" #Then
			#If StrContains("#Parameter(9)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(9)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(10)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(10)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(10))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(11) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without brackets.

//// Checking the field value of parameter group 3
#If "#Parameter(12)" = "" AND "#Parameter(13)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(12)" = "Condition" OR "#Parameter(12)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(13) )
#ElsIf "#Parameter(12)" = "ReadRight" OR "#Parameter(12)" = "EditRight" #Then
	 #Parameter(13) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
 
AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(13))
		#If Not "#Parameter(12)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(12)" = "Object" OR "#Parameter(12)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(13))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights.
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
 
AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(13))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(13)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(13)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(13)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(13)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(13)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(13)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(13)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(12)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(12)", ",") #Then
		IncorrectAccessKind: "#Parameter(12)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(12)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),") #Then
	
	 (
			ISNULL(#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(12),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(13)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(13)
		#ElsIf "#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(12)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(13)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(13))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(14) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 4
#If "#Parameter(15)" = "" AND "#Parameter(16)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(15)" = "Condition" OR "#Parameter(15)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(16) )
#ElsIf "#Parameter(15)" = "ReadRight" OR "#Parameter(15)" = "EditRight" #Then
	 #Parameter(16) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(16))
		#If Not "#Parameter(15)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(15)" = "Object" OR "#Parameter(15)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(16))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read Right
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit Right
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(16))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(16)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(16)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled.
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(16)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(16)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(16)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(16)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(16)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(15)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(15),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(15)", ",") #Then
		IncorrectAccessKind: "#Parameter(15)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(15)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(15),") #Then
	
	 (
			ISNULL(#Parameter(16), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(15),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(15),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(16)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(16)
		#ElsIf "#Parameter(16)" = "T.Ref" #Then
			#If StrContains("#Parameter(15)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(15)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(16)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(16)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(16))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(17) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 5
#If "#Parameter(18)" = "" AND "#Parameter(19)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(18)" = "Condition" OR "#Parameter(18)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(19) )
#ElsIf "#Parameter(18)" = "ReadRight" OR "#Parameter(18)" = "EditRight" #Then
	 #Parameter(19) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(19))
		#If Not "#Parameter(18)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(18)" = "Object" OR "#Parameter(18)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(19))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right
				// Read right can depend only on the Read right
			#Else
				// Checking the leading right for the Edit right
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(19))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(19)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(19)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(19)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(19)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(19)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(19)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(19)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(18)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(18)", ",") #Then
		IncorrectAccessKind: "#Parameter(18)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(18)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),") #Then
	
	 (
			ISNULL(#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(18),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(19)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(19)
		#ElsIf "#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(18)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(19)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(19))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(20) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 6
#If "#Parameter(21)" = "" AND "#Parameter(22)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(21)" = "Condition" OR "#Parameter(21)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(22) )
#ElsIf "#Parameter(21)" = "ReadRight" OR "#Parameter(21)" = "EditRight" #Then
	 #Parameter(22) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(22))
		#If Not "#Parameter(21)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(21)" = "Object" OR "#Parameter(21)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(22))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right
				// Read right can depend only on the Read right
			#Else
				// Checking the leading right for the Edit right
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(22))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(22)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(22)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled.
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(22)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(22)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(22)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(22)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(22)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(21)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(21),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(21)", ",") #Then
		IncorrectAccessKind: "#Parameter(21)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(21)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(21),") #Then
	
	 (
			ISNULL(#Parameter(22), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(21),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(21),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(22)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(22)
		#ElsIf "#Parameter(22)" = "T.Ref" #Then
			#If StrContains("#Parameter(21)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(21)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(22)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(22)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(22))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(23) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 7
#If "#Parameter(24)" = "" AND "#Parameter(25)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(24)" = "Condition" OR "#Parameter(24)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(25) )
#ElsIf "#Parameter(24)" = "ReadRight" OR "#Parameter(24)" = "EditRight" #Then
	 #Parameter(25) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(25))
		#If Not "#Parameter(24)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(24)" = "Object" OR "#Parameter(24)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(25))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(25))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(25)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(25)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(25)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(25)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(25)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(25)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(25)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(24)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(24)", ",") #Then
		IncorrectAccessKind: "#Parameter(24)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(24)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),") #Then
	
	 (
			ISNULL(#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(24),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(25)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(25)
		#ElsIf "#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(24)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(25)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(25))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(26) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 8
#If "#Parameter(27)" = "" AND "#Parameter(28)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(27)" = "Condition" OR "#Parameter(27)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(28) )
#ElsIf "#Parameter(27)" = "ReadRight" OR "#Parameter(27)" = "EditRight" #Then
	 #Parameter(28) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(28))
		#If Not "#Parameter(27)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(27)" = "Object" OR "#Parameter(27)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(28))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit Right
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(28))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(28)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(28)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled.
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(28)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(28)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(28)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(28)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(28)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(27)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(27),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(27)", ",") #Then
		IncorrectAccessKind: "#Parameter(27)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(27)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(27),") #Then
	
	 (
			ISNULL(#Parameter(28), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(27),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(27),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(28)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(28)
		#ElsIf "#Parameter(28)" = "T.Ref" #Then
			#If StrContains("#Parameter(27)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(27)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(28)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(28)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(28))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(29) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 9
#If "#Parameter(30)" = "" AND "#Parameter(31)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(30)" = "Condition" OR "#Parameter(30)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(31) )
#ElsIf "#Parameter(30)" = "ReadRight" OR "#Parameter(30)" = "EditRight" #Then
	 #Parameter(31) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(31))
		#If Not "#Parameter(30)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(30)" = "Object" OR "#Parameter(30)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(31))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(31))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(31)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(31)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(31)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(31)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(31)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(31)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(31)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(30)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(30)", ",") #Then
		IncorrectAccessKind: "#Parameter(30)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(30)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),") #Then
	
	 (
			ISNULL(#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(30),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(31)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(31)
		#ElsIf "#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(30)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(31)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(31))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(32) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 10
#If "#Parameter(33)" = "" AND "#Parameter(34)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(33)" = "Condition" OR "#Parameter(33)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(34) )
#ElsIf "#Parameter(33)" = "ReadRight" OR "#Parameter(33)" = "EditRight" #Then
	 #Parameter(34) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(34))
		#If Not "#Parameter(33)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(33)" = "Object" OR "#Parameter(33)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(34))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(34))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(34)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(34)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(34)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(34)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(34)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(34)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(34)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(33)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(33),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(33)", ",") #Then
		IncorrectAccessKind: "#Parameter(33)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(33)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(33),") #Then
	
	 (
			ISNULL(#Parameter(34), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(33),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(33),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(34)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(34)
		#ElsIf "#Parameter(34)" = "T.Ref" #Then
			#If StrContains("#Parameter(33)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(33)" - "Only one access kind can be specified during the access value table check""
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(34)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(34)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(34))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(35) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 11
#If "#Parameter(36)" = "" AND "#Parameter(37)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(36)" = "Condition" OR "#Parameter(36)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(37) )
#ElsIf "#Parameter(36)" = "ReadRight" OR "#Parameter(36)" = "EditRight" #Then
	 #Parameter(37) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(37))
		#If Not "#Parameter(36)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(36)" = "Object" OR "#Parameter(36)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(37))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(37))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(37)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(37)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(37)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(37)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(37)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(37)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(37)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(36)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(36),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(36)", ",") #Then
		IncorrectAccessKind: "#Parameter(36)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(36)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(36),") #Then
	
	 (
			ISNULL(#Parameter(37), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(36),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(36),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(37)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(37)
		#ElsIf "#Parameter(37)" = "T.Ref" #Then
			#If StrContains("#Parameter(36)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(36)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(37)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(37)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(37))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(38) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 12
#If "#Parameter(39)" = "" AND "#Parameter(40)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(39)" = "Condition" OR "#Parameter(39)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(40) )
#ElsIf "#Parameter(39)" = "ReadRight" OR "#Parameter(39)" = "EditRight" #Then
	 #Parameter(40) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(40))
		#If Not "#Parameter(39)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(39)" = "Object" OR "#Parameter(39)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(40))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(40))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(40)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(40)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(40)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(40)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(40)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(40)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(40)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(39)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(39),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(39)", ",") #Then
		IncorrectAccessKind: "#Parameter(39)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(39)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(39),") #Then
	
	 (
			ISNULL(#Parameter(40), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(39),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(39),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(40)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(40)
		#ElsIf "#Parameter(40)" = "T.Ref" #Then
			#If StrContains("#Parameter(39)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(39)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(40)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(40)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(40))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(41) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 13
#If "#Parameter(42)" = "" AND "#Parameter(43)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(42)" = "Condition" OR "#Parameter(42)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(43) )
#ElsIf "#Parameter(42)" = "ReadRight" OR "#Parameter(42)" = "EditRight" #Then
	 #Parameter(43) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(43))
		#If Not "#Parameter(42)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(42)" = "Object" OR "#Parameter(42)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(43))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read Right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(43))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(43)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(43)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(43)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(43)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(43)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(43)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(43)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(42)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(42),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(42)", ",") #Then
		IncorrectAccessKind: "#Parameter(42)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(42)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(42),") #Then
	
	 (
			ISNULL(#Parameter(43), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(42),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(42),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(43)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(43)
		#ElsIf "#Parameter(43)" = "T.Ref" #Then
			#If StrContains("#Parameter(42)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(42)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(43)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(43)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(43))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(44) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 14
#If "#Parameter(45)" = "" AND "#Parameter(46)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(45)" = "Condition" OR "#Parameter(45)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(46) )
#ElsIf "#Parameter(45)" = "ReadRight" OR "#Parameter(45)" = "EditRight" #Then
	 #Parameter(46) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(46))
		#If Not "#Parameter(45)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(45)" = "Object" OR "#Parameter(45)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(46))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(46))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(46)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(46)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled.
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(46)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(46)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(46)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(46)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(46)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(45)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(45),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(45)", ",") #Then
		IncorrectAccessKind: "#Parameter(45)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(45)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(45),") #Then
	
	 (
			ISNULL(#Parameter(46), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(45),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(45),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(46)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(46)
		#ElsIf "#Parameter(46)" = "T.Ref" #Then
			#If StrContains("#Parameter(45)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(45)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(46)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(46)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(46))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(47) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 15
#If "#Parameter(48)" = "" AND "#Parameter(49)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(48)" = "Condition" OR "#Parameter(48)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(49) )
#ElsIf "#Parameter(48)" = "ReadRight" OR "#Parameter(48)" = "EditRight" #Then
	 #Parameter(49) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(49))
		#If Not "#Parameter(48)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(48)" = "Object" OR "#Parameter(48)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(49))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit right.
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(49))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(49)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(49)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(49)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(49)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(49)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(49)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(49)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(48)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(48),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(48)", ",") #Then
		IncorrectAccessKind: "#Parameter(48)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(48)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(48),") #Then
	
	 (
			ISNULL(#Parameter(49), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(48),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(48),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(49)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(49)
		#ElsIf "#Parameter(49)" = "T.Ref" #Then
			#If StrContains("#Parameter(48)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(48)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(49)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(49)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(49))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(50) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

//// Checking the field value of parameter group 16
#If "#Parameter(51)" = "" AND "#Parameter(52)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(51)" = "Condition" OR "#Parameter(51)" = "" #Then
	// When the access kind name is "Condition" or "", a condition is set instead of the field name
	 ( #Parameter(52) )
#ElsIf "#Parameter(51)" = "ReadRight" OR "#Parameter(51)" = "EditRight" #Then
	 #Parameter(52) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(52))
		#If Not "#Parameter(51)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(51)" = "Object" OR "#Parameter(51)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(52))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the leading right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Edit Right.
				// Edit right can depend on the Read or Edit leading rights
				AND Not
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND Not TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(52))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(52)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(52)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(52)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(52)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND Not
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(52)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(52)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 Not FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(52)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						Not TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking a user access right to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // Not FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(51)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND Not FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(51),") #Then
	// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
	#If StrContains("#Parameter(51)", ",") #Then
		IncorrectAccessKind: "#Parameter(51)" - "The list of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(51)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(51),") #Then
	
	 (
			ISNULL(#Parameter(52), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(51),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(51),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(52)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(52)
		#ElsIf "#Parameter(52)" = "T.Ref" #Then
			#If StrContains("#Parameter(51)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an error during access restriction assembly
				IncorrectAccessKind: "#Parameter(51)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(52)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(52)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(52))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(53) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets

 )
)
#EndIf

</condition>
	</restrictionTemplate>
</Rights>