<?xml version="1.0" encoding="UTF-8"?>
<Rights xmlns="http://v8.1c.ru/8.2/roles" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Rights" version="2.3">
	<setForNewObjects>false</setForNewObjects>
	<setForAttributesByDefault>true</setForAttributesByDefault>
	<independentRightsOfChildObjects>false</independentRightsOfChildObjects>
	<object>
		<name>Catalog.EmailAccounts.Attribute.Password</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonCommand.AccessRights</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPAuthenticationMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPPassword</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UseForSending</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPAuthentication</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.KeepMessageCopiesAtServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.OutgoingMailServerPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Predefined</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Ref</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.DeletionMark</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.IsFolder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Owner</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Parent</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Description</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.StandardAttribute.Code</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.IncomingMailServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonForm.AccessRights</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.SMTPUser</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UseForReceiving</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.Timeout</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.EmailAddress</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.IncomingMailServerPort</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.KeepMessagesOnServerPeriod</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.UserName</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroups</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>AccessGroups
WHERE
	AccessGroups.IsFolder
	OR TRUE IN
		(SELECT TOP 1
			TRUE
		FROM
			InformationRegister.UserGroupContent AS UserGroupContent
				WHERE
					 UserGroupContent.UserGroup = AccessGroups.Responsible
				#If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
					AND UserGroupContent.User = &amp;CurrentUser
				#Else
					AND UserGroupContent.User = &amp;CurrentExternalUser
				#EndIf
		 )
	AND Selection
		When AccessGroups.Ref = Value(Catalog.AccessGroups.Administrators)
		Then AccessGroups.Profile = Value(Catalog.AccessGroupProfiles.Administrator)
		Else AccessGroups.Profile &lt;&gt; Value(Catalog.AccessGroupProfiles.Administrator)
	End
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>AccessGroups
WHERE
	AccessGroups.IsFolder
	OR TRUE IN
		(SELECT TOP 1
			TRUE
		FROM
			InformationRegister.UserGroupContent AS UserGroupContent
				WHERE
					 UserGroupContent.UserGroup = AccessGroups.Responsible
				#If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
					AND UserGroupContent.User = &amp;CurrentUser
				#Else
					AND UserGroupContent.User = &amp;CurrentExternalUser
				#EndIf
		 )
	AND Selection
		When AccessGroups.Ref = Value(Catalog.AccessGroups.Administrators)
		Then AccessGroups.Profile = Value(Catalog.AccessGroupProfiles.Administrator)
		Else AccessGroups.Profile &lt;&gt; Value(Catalog.AccessGroupProfiles.Administrator)
	End
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.User</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.OutgoingMailServer</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.AccessGroupProfiles</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>AccessGroupProfiles
WHERE
 AccessGroupProfiles.IsFolder
 OR TRUE IN
 (SELECT TOP 1
 TRUE
 FROM
 InformationRegister.UserGroupContent AS UserGroupContent
 INNER JOIN Catalog.AccessGroups AS AccessGroups
 ON
 AccessGroups.Profile = AccessGroupProfiles.Ref
 AND UserGroupContent.UserGroup = AccessGroups.Responsible
 #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
 AND UserGroupContent.User = &amp;CurrentUser
 #Else
 AND UserGroupContent.User = &amp;CurrentExternalUser
 #EndIf
 AND Selection
 When AccessGroups.Ref = Value(Catalog.AccessGroups.Administrators)
 Then AccessGroups.Profile = Value(Catalog.AccessGroupProfiles.Administrator)
 Else AccessGroups.Profile &lt;&gt; Value(Catalog.AccessGroupProfiles.Administrator)
 End
 )
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.EmailAccounts.Attribute.POP3AuthenticationMode</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<restrictionTemplate>
		<name>ByValues</name>
		<condition>// ByValues(Table, -, Modifier, A1,P1, A2,P2, ..., A(n), P(n)).
// Parameter #: 1, 2, 3, 4, 5, 6, 7, ..., 2+n*2,3+n*2.
// Read as: "access restriction by value".
// Parameters:
// Table - The current table name, for example, Document.ProductAndServiceReceipt.
// Modifier - changes the template.
// Modifier 1 - the string DontLimitAccessToGroups specifies that groups of the hierarchical catalog must be selected unconditionally.
// No other modifiers are available in this version of the template.
// A(n) - Access kind - name of access kind, for example, "Companies".
// For composite type fields, you can improve performance by specifying multiple names, for example, "Companies,IndividualGroups", rather than use several parameter blocks with the same field name.
// You can use special access kinds such as "Condition", "RightsSettings", "ReadRight", "EditRight" only separately.
// When A(n) = "Condition" (or ""), then P(n) contains a condition string written in the query language, for example,
// "T.Author = &amp;AuthorizedUser", "VALUETYPE(T.Owner) = TYPE(Catalog.Companies)", where T is the current table alias.
// When A(n) = "ReadRight" Or "EditRight", rights for the T.P(n) value table are checked.
// P(n) - Validated value field, except when A(n) = "Condition" (or "").
// Note: you can increase the maximum number of field values checked
// at the same time by changing the template, but you must specify all template parameters, i.e. include empty rows when the number of fields is below maximum.
// The template has the following structure:
// &lt;Common part of conditions&gt; &lt;Condition by parameter group 1&gt; AND &lt;Condition by parameter group 2&gt; AND ... &lt;Condition by parameter group(n)&gt;
// Example:
// ByValues("Document.ProductAndServiceReceipt", "", "",
// "Companies","Company",
// "Vendors","Counterparty", "","", ...)

// Validating the Right parameter
#If Not ("#Parameter(2)" = "Read" OR "#Parameter(2)" = "Insert" OR
"#Parameter(2)" = "Update" OR "#Parameter(2)" = "Delete" OR "#Parameter(2)" = "")
 OR #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)" = "Read"
 OR #CurrentAccessRightName = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is invalid, a string is inserted to raise an access restriction assembly error
 InvalidRight: #Parameter(2)
#EndIf

// Validating the TableName parameter
#If "#Parameter(1)" &lt;&gt; #CurrentTypeName #Then
// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter
#If Not ("#Parameter(3)" = "DontLimitAccessToGroups" OR "#Parameter(3)" = "") #Then
// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	InvalidModifier: #Parameter(3)
#EndIf

// Making the general check whether access restrictions are used at the record level,
// and checking whether at least one restriction from the specified access kinds is used
#If &amp;UseRecordLevelSecurity
 AND Not (True
 AND ("#Parameter(4)" = "" AND "#Parameter(5)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(4),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(4),"))
 AND ("#Parameter(6)" = "" AND "#Parameter(7)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(6),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),"))
 AND ("#Parameter(8)" = "" AND "#Parameter(9)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(8),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(8),"))
 AND ("#Parameter(10)" = "" AND "#Parameter(11)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(10),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(10),"))
 AND ("#Parameter(12)" = "" AND "#Parameter(13)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(12),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),"))
 AND ("#Parameter(14)" = "" AND "#Parameter(15)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(14),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(14),"))
 AND ("#Parameter(16)" = "" AND "#Parameter(17)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(16),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(16),"))
 AND ("#Parameter(18)" = "" AND "#Parameter(19)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(18),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),"))
 AND ("#Parameter(20)" = "" AND "#Parameter(21)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(20),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(20),"))
 AND ("#Parameter(22)" = "" AND "#Parameter(23)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(22),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(22),"))
 AND ("#Parameter(24)" = "" AND "#Parameter(25)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(24),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),"))
 AND ("#Parameter(26)" = "" AND "#Parameter(27)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(26),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(26),"))
 AND ("#Parameter(28)" = "" AND "#Parameter(29)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(28),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(28),"))
 AND ("#Parameter(30)" = "" AND "#Parameter(31)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(30),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),"))
 AND ("#Parameter(32)" = "" AND "#Parameter(33)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(32),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(32),"))
 AND ("#Parameter(34)" = "" AND "#Parameter(35)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(34),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(34),"))
 ) #Then

T WHERE // T is the current table alias (intentionally shortened in order to minimize the number of characters in the text of the condition parameter in the query language)

// Unconditional selection of folders in a hierarchical metadata object (if required)
#If "#Parameter(3)" = "DontLimitAccessToGroups" #Then
	T.IsFolder OR
#EndIf

TRUE IN
( // Checking user rights for the entire current table.
	// Rights for tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
		Catalog.MetadataObjectIDs AS CurrentTableProperties
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			 (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupTables AS AccessGroupTables
					WHERE
						 AccessGroupTables.Table = CurrentTableProperties.Ref
						AND AccessGroupTables.AccessGroup = AccessGroups.Ref
					#If Not #CurrentAccessRightName = "Read" #Then
						AND AccessGroupTables.Update
					#EndIf
			 )
			AND AccessGroups.Ref IN
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
					ON
						 UserGroupContent.User = &amp;AuthorizedUser
						AND UserGroupContent.UserGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Searching for values of the specified fields in the allowed values of access groups (users)
 
//// Checking the field value of parameter group 1
#If "#Parameter(4)" = "Condition" OR "#Parameter(4)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	( #Parameter(5) )
#ElsIf "#Parameter(4)" = "ReadRight" OR "#Parameter(4)" = "EditRight" #Then
	 T.#Parameter(5) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(5))
		#If Not "#Parameter(4)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(4)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(5)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(5)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(4),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(4)", ",") #Then
		IncorrectAccessKind: "#Parameter(4)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(4)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(4),") #Then
	
	 (
			ISNULL(T.#Parameter(5), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(4),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(4),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(5)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(4),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(5)
		#ElsIf "T.#Parameter(5)" = "T.Ref" #Then
			#If StrContains("#Parameter(4)", ",") #Then
// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(4)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(4),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(5)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(5)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(5))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

//// Checking the field value of parameter group 2
#If "#Parameter(6)" = "" AND "#Parameter(7)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(6)" = "Condition" OR "#Parameter(6)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(7) )
#ElsIf "#Parameter(6)" = "ReadRight" OR "#Parameter(6)" = "EditRight" #Then
	AND T.#Parameter(7) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(7))
		#If Not "#Parameter(6)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(6)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(7)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(7)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(6)", ",") #Then
		IncorrectAccessKind: "#Parameter(6)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(6)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),") #Then
	AND
	 (
			ISNULL(T.#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(6),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(7)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(7)
		#ElsIf "T.#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(6)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
				 AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(7)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(7))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 3
#If "#Parameter(8)" = "" AND "#Parameter(9)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(8)" = "Condition" OR "#Parameter(8)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(9) )
#ElsIf "#Parameter(8)" = "ReadRight" OR "#Parameter(8)" = "EditRight" #Then
	AND T.#Parameter(9) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(9))
		#If Not "#Parameter(8)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(8)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(9)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(9)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(8),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(8)", ",") #Then
		IncorrectAccessKind: "#Parameter(8)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(8)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(8),") #Then
	AND
	 (
			ISNULL(T.#Parameter(9), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(8),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(8),", ",ExternalUsers,")) #Then
			Not
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(9)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(8),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(9)
		#ElsIf "T.#Parameter(9)" = "T.Ref" #Then
			#If StrContains("#Parameter(8)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(8)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(8),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(9)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(9)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(9))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking field value of the parameter 4 group.
#If "#Parameter(10)" = "" AND "#Parameter(11)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(10)" = "Condition" OR "#Parameter(10)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(11) )
#ElsIf "#Parameter(10)" = "ReadRight" OR "#Parameter(10)" = "EditRight" #Then
	AND T.#Parameter(11) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(11))
		#If Not "#Parameter(10)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(10)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(11)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(11)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(10),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(10)", ",") #Then
		IncorrectAccessKind: "#Parameter(10)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(10)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(10),") #Then
	AND
	 (
			ISNULL(T.#Parameter(11), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(10),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(10),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(11)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(10),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(11)
		#ElsIf "T.#Parameter(11)" = "T.Ref" #Then
			#If StrContains("#Parameter(10)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(10)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(10),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(11)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(11)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(11))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking field value of the parameter 5 group
#If "#Parameter(12)" = "" AND "#Parameter(13)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(12)" = "Condition" OR "#Parameter(12)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name.
	AND ( #Parameter(13) )
#ElsIf "#Parameter(12)" = "ReadRight" OR "#Parameter(12)" = "EditRight" #Then
	AND T.#Parameter(13) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(13))
		#If Not "#Parameter(12)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(12)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(13)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(13)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(12)", ",") #Then
		IncorrectAccessKind: "#Parameter(12)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(12)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),") #Then
	AND
	 (
			ISNULL(T.#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(12),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(13)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(13)
		#ElsIf "T.#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(12)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(13)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(13))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 6
#If "#Parameter(14)" = "" AND "#Parameter(15)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(14)" = "Condition" OR "#Parameter(14)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(15) )
#ElsIf "#Parameter(14)" = "ReadRight" OR "#Parameter(14)" = "EditRight" #Then
	AND T.#Parameter(15) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(15))
		#If Not "#Parameter(14)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(14)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(15)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(15)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(14),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(14)", ",") #Then
		IncorrectAccessKind: "#Parameter(14)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(14)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(14),") #Then
	AND
	 (
			ISNULL(T.#Parameter(15), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(14),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(14),", ",ExternalUsers,")) #Then
			Not
			(
			Not TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(15)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(14),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
			AND Values.AccessValue = T.#Parameter(15)
		#ElsIf "T.#Parameter(15)" = "T.Ref" #Then
			#If StrContains("#Parameter(14)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(14)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(14),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
			AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(15)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(15)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(15))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 7
#If "#Parameter(16)" = "" AND "#Parameter(17)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(16)" = "Condition" OR "#Parameter(16)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(17) )
#ElsIf "#Parameter(16)" = "ReadRight" OR "#Parameter(16)" = "EditRight" #Then
	AND T.#Parameter(17) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(17))
		#If Not "#Parameter(16)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(16)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(17)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(17)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(16),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(16)", ",") #Then
		IncorrectAccessKind: "#Parameter(16)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(16)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(16),") #Then
	AND
	 (
			ISNULL(T.#Parameter(17), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(16),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(16),", ",ExternalUsers,")) #Then
			Not
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(17)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(16),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(17)
		#ElsIf "T.#Parameter(17)" = "T.Ref" #Then
			#If StrContains("#Parameter(16)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(16)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(16),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(17)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(17)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(17))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 8
#If "#Parameter(18)" = "" AND "#Parameter(19)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(18)" = "Condition" OR "#Parameter(18)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(19) )
#ElsIf "#Parameter(18)" = "ReadRight" OR "#Parameter(18)" = "EditRight" #Then
	AND T.#Parameter(19) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(19))
		#If Not "#Parameter(18)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(18)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(19)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(19)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(18)", ",") #Then
		IncorrectAccessKind: "#Parameter(18)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(18)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),") #Then
	AND
	 (
			ISNULL(T.#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(18),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(19)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(19)
		#ElsIf "T.#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(18)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(19)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(19))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 9
#If "#Parameter(20)" = "" AND "#Parameter(21)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(20)" = "Condition" OR "#Parameter(20)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(21) )
#ElsIf "#Parameter(20)" = "ReadRight" OR "#Parameter(20)" = "EditRight" #Then
	AND T.#Parameter(21) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(21))
		#If Not "#Parameter(20)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(20)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(21)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(21)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(20),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(20)", ",") #Then
		IncorrectAccessKind: "#Parameter(20)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(20)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(20),") #Then
	AND
	 (
			ISNULL(T.#Parameter(21), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(20),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(20),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(21)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(20),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(21)
		#ElsIf "T.#Parameter(21)" = "T.Ref" #Then
			#If StrContains("#Parameter(20)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(20)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(20),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(21)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(21)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(21))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 10
#If "#Parameter(22)" = "" AND "#Parameter(23)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(22)" = "Condition" OR "#Parameter(22)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(23) )
#ElsIf "#Parameter(22)" = "ReadRight" OR "#Parameter(22)" = "EditRight" #Then
	AND T.#Parameter(23) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(23))
		#If Not "#Parameter(22)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(22)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(23)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(23)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(22),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(22)", ",") #Then
		IncorrectAccessKind: "#Parameter(22)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(22)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(22),") #Then
	AND
	 (
			ISNULL(T.#Parameter(23), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(22),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(22),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(23)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND Not
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(22),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(23)
		#ElsIf "T.#Parameter(23)" = "T.Ref" #Then
			#If StrContains("#Parameter(22)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(22)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(22),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(23)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(23)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(23))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 11
#If "#Parameter(24)" = "" AND "#Parameter(25)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(24)" = "Condition" OR "#Parameter(24)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(25) )
#ElsIf "#Parameter(24)" = "ReadRight" OR "#Parameter(24)" = "EditRight" #Then
	AND T.#Parameter(25) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(25))
		#If Not "#Parameter(24)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(24)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(25)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(25)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(24)", ",") #Then
		IncorrectAccessKind: "#Parameter(24)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(24)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),") #Then
	AND
	 (
			ISNULL(T.#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(24),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(25)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(25)
		#ElsIf "T.#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(24)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(25)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(25))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 12
#If "#Parameter(26)" = "" AND "#Parameter(27)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(26)" = "Condition" OR "#Parameter(26)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(27) )
#ElsIf "#Parameter(26)" = "ReadRight" OR "#Parameter(26)" = "EditRight" #Then
	AND T.#Parameter(27) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(27))
		#If Not "#Parameter(26)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(26)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(27)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(27)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(26),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(26)", ",") #Then
		IncorrectAccessKind: "#Parameter(26)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(26)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(26),") #Then
	AND
	 (
			ISNULL(T.#Parameter(27), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(26),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(26),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(27)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(26),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
				 	 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(27)
		#ElsIf "T.#Parameter(27)" = "T.Ref" #Then
			#If StrContains("#Parameter(26)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(26)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(26),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
				 	 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(27)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(27)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(27))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 13
#If "#Parameter(28)" = "" AND "#Parameter(29)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(28)" = "Condition" OR "#Parameter(28)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(29) )
#ElsIf "#Parameter(28)" = "ReadRight" OR "#Parameter(28)" = "EditRight" #Then
	AND T.#Parameter(29) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(29))
		#If Not "#Parameter(28)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(28)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(29)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) 
 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(29)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(28),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(28)", ",") #Then
		IncorrectAccessKind: "#Parameter(28)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(28)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(28),") #Then
	AND
	 (
			ISNULL(T.#Parameter(29), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(28),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(28),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(29)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(28),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(29)
		#ElsIf "T.#Parameter(29)" = "T.Ref" #Then
			#If StrContains("#Parameter(28)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(28)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(28),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(29)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(29)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(29))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 14
#If "#Parameter(30)" = "" AND "#Parameter(31)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(30)" = "Condition" OR "#Parameter(30)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(31) )
#ElsIf "#Parameter(30)" = "ReadRight" OR "#Parameter(30)" = "EditRight" #Then
	AND T.#Parameter(31) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(31))
		#If Not "#Parameter(30)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(30)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(31)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) 
 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(31)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(30)", ",") #Then
		IncorrectAccessKind: "#Parameter(30)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(30)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),") #Then
	AND
	 (
			ISNULL(T.#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(30),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(31)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(31)
		#ElsIf "T.#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(30)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(31)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(31))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 15
#If "#Parameter(32)" = "" AND "#Parameter(33)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(32)" = "Condition" OR "#Parameter(32)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(33) )
#ElsIf "#Parameter(32)" = "ReadRight" OR "#Parameter(32)" = "EditRight" #Then
	AND T.#Parameter(33) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(33))
		#If Not "#Parameter(32)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(32)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(33)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) 
 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(33)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(32),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(32)", ",") #Then
		IncorrectAccessKind: "#Parameter(32)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(32)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(32),") #Then
	AND
	 (
			ISNULL(T.#Parameter(33), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(32),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(32),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(33)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(32),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(33)
		#ElsIf "T.#Parameter(33)" = "T.Ref" #Then
			#If StrContains("#Parameter(32)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(32)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(32),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(33)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(33)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(33))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

//// Checking the field value of parameter group 16
#If "#Parameter(34)" = "" AND "#Parameter(35)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(34)" = "Condition" OR "#Parameter(34)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	AND ( #Parameter(35) )
#ElsIf "#Parameter(34)" = "ReadRight" OR "#Parameter(34)" = "EditRight" #Then
	AND T.#Parameter(35) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(35))
		#If Not "#Parameter(34)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(34)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(35)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) 
 AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = T.#Parameter(35)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(34),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(34)", ",") #Then
		IncorrectAccessKind: "#Parameter(34)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(34)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(34),") #Then
	AND
	 (
			ISNULL(T.#Parameter(35), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(34),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(34),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = T.#Parameter(35)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(34),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(35)
		#ElsIf "T.#Parameter(35)" = "T.Ref" #Then
			#If StrContains("#Parameter(34)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(34)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(34),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(35)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(35)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(35))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

 )
)
#EndIf

				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = T.#Parameter(35)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = T.#Parameter(35)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(T.#Parameter(35))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#EndIf

 )
)
#EndIf

</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValuesAndSetsAdvanced</name>
		<condition>// ByValuesAndSetsAdvanced(Table, -, Modifier, JoinedTables, B, A1,F1,B1, A2,F2,B2,..., A(n), F(n), B(n)).
// Parameter #: 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,...,3+n*3,4+n*3,5+n*3.
// Read as: "access restriction by values and sets advanced".
// Parameters:
// Table - The current table name, for example, Document.ProductAndServiceReceipt.
// Modifier - changes the template.
// Modifier 1 - the string DontLimitAccessToGroups specifies that groups of the hierarchical catalog should be selected unconditionally
// Modifier 2 - the AdvancedOR string enables advanced check for restrictions, for example, ByCompanies or ByAccounts)
// where access kind setting option in access groups "All allowed, none prohibited" is considered as "Access kind is not used".
// If this modifier is not used, the check
// result is True and therefore the final result is also True provided that "All allowed, none prohibited" option is set
// for at least one access kind (either ByCompanies or ByAccounts).
// Modifier is intended for use only when checking access value sets.
// You can combine modifiers as follows: "DontLimitAccessToGroups", "AdvancedOR", "DontLimitAccessToGroups, AdvancedOR".
// No other modifiers are available in this version of the template.
// JoinedTables - the text of command used to join the additional tables in the query language such as "INNER JOIN
// Document.AdvanceReport.PaymentToVendor AS T1 On T.Link = T1.Ref".
// Joining allows to define fields of PaymentToVendor table as
// fields of main table, in order to check values of those fields as if they were main table field values.
// The user should keep in mind that when strings multiply as a result of the joining, it is enough for any string
// to satisfy the check condition, so the string check results are joined by "OR".
// B - Leading brackets "(".
// A(n) - Access kind - name of access kind, for example, "Companies". For composite type fields, you
// can improve performance by specifying multiple names, for example, "Companies,IndividualGroups", rather than use several parameter blocks with the same field name.
// Special access kinds "Object", "Condition", "RightsSettings",
// "ReadRight" "EditRight" can be used only separately.
// When A(n) = "Condition" or "", P(n) contains a condition string in the query language, for example, "T.Author = &amp;AuthorizedUser", "VALUETYPE(T.Owner) = TYPE(Reference.Companies)" where T - alias of current table.
// When A(n) = "ReadRight" OR "EditRight", a check is made whether the right to read or write T.P(n) value table is available.
// When A(n) = "Object" (or " "), then if a record of a right dependency is available in the AccessRightDependencies information register, a check is made whether
// the right to read T.P(n) and the access value sets (stored in the AccessValueSets information register and read by T.P(n) reference for a read right) is available;
// otherwise the standard rule is used:
// when Right = "Read", a check is made whether the right to
// read T.P(n) and access value sets (stored in the AccessValueSets information register and read by T.P.(n) reference for a read right) is available;;
// when Right = "Edit" then a check is made whether the right to edit T.P(n) and access value sets read by T.P(n) reference for an edit right is available.
// P(n) - The field of a checked value with an alias, for example, "T.Company", except for cases when A(n) = "Condition" (or "").
// O(n) - Logical operations "AND", "OR" in combination with brackets "(", ")".
// Note: you can increase the maximum number of field values checked
// at the same time by changing the template, but you must specify all template parameters, i.e. include empty rows when the number of fields is below maximum.
// The template has the following structure:
// &lt;Joining by table1&gt; &lt;Joining by table2&gt; ... &lt;Joining
// by table(m)&gt; &lt;Common part of conditions&gt; &lt;Condition by parameter group 1&gt; AND/OR &lt;Condition by parameter group 1&gt; AND/OR ... &lt;Condition by the parameter group(n)&gt;
// Example:
// ByValuesAndSetsAdvanced("DocumentJournal.WarehouseDocuments", "", "",
// "",
// "",
// "Object","T.Ref","And",
// "Object","T.MainDocument","", "","","", ...)

// Validating the Right parameter
#If Not ("#Parameter(2)" = "Read" OR "#Parameter(2)" = "Insert" OR
"#Parameter(2)" = "Update" OR "#Parameter(2)" = "Delete" OR "#Parameter(2)" = "")
 OR #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)" = "Read"
 OR #CurrentAccessRightName = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is invalid, a string is inserted to raise an access restriction assembly error
 InvalidRight: #Parameter(2)
#EndIf

// Validating the Modifier parameter TableName
#If "#Parameter(1)" &lt;&gt; #CurrentTypeName #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter
#If Not ( "#Parameter(3)" = "DontLimitAccessToGroups"
 OR "#Parameter(3)" = "AdvancedOR"
 OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR"
 OR "#Parameter(3)" = "") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	InvalidModifier: #Parameter(3)
#EndIf

// Making the general check whether access restrictions are
// used at the record level. Checking whether at least one restriction from the specified access kinds is used.
#If &amp;UseRecordLevelSecurity
 AND Not (True
 AND ("#Parameter(6)" = "" AND "#Parameter(7)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(6),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),"))
 AND ("#Parameter(9)" = "" AND "#Parameter(10)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(9),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(9),"))
 AND ("#Parameter(12)" = "" AND "#Parameter(13)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(12),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),"))
 AND ("#Parameter(15)" = "" AND "#Parameter(16)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(15),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(15),"))
 AND ("#Parameter(18)" = "" AND "#Parameter(19)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(18),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),"))
 AND ("#Parameter(21)" = "" AND "#Parameter(22)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(21),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(21),"))
 AND ("#Parameter(24)" = "" AND "#Parameter(25)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(24),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),"))
 AND ("#Parameter(27)" = "" AND "#Parameter(28)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(27),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(27),"))
 AND ("#Parameter(30)" = "" AND "#Parameter(31)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(30),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),"))
 AND ("#Parameter(33)" = "" AND "#Parameter(34)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(33),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(33),"))
 AND ("#Parameter(36)" = "" AND "#Parameter(37)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(36),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(36),"))
 AND ("#Parameter(39)" = "" AND "#Parameter(40)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(39),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(39),"))
 AND ("#Parameter(42)" = "" AND "#Parameter(43)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(42),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(42),"))
 AND ("#Parameter(45)" = "" AND "#Parameter(46)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(45),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(45),"))
 AND ("#Parameter(48)" = "" AND "#Parameter(49)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(48),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(48),"))
 AND ("#Parameter(51)" = "" AND "#Parameter(52)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(51),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(51),"))
 ) #Then

T FROM T // T is the current table alias (intentionally shortened in order to minimize the number of characters in the text of the condition parameter in the query language)

// Tables joined to the row of the current table T that is being checked
#Parameter(4)

WHERE

// Unconditional selection of folders in a hierarchical metadata object (if required)
#If "#Parameter(3)" = "DontLimitAccessToGroups" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
	T.IsFolder OR
#EndIf

TRUE IN
(	// Checking user rights for the entire current table.
	// Rights for tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
		Catalog.MetadataObjectIDs AS CurrentTableProperties
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			 (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupTables AS AccessGroupTables
					WHERE
						 AccessGroupTables.Table = CurrentTableProperties.Ref
						AND AccessGroupTables.AccessGroup = AccessGroups.Ref
					#If Not #CurrentAccessRightName = "Read" #Then
						AND AccessGroupTables.Update
					#EndIf
			 )
			AND AccessGroups.Ref IN
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
					ON
						 UserGroupContent.User = &amp;AuthorizedUser
						AND UserGroupContent.UserGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Searching for values of the specified fields in the allowed values of access groups (users)

	#Parameter(5) // [([(][(]...] 0-n opening brackets.

//// Checking the field value of parameter group 1
#If "#Parameter(6)" = "Condition" OR "#Parameter(6)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	( #Parameter(7) )
#ElsIf "#Parameter(6)" = "ReadRight" OR "#Parameter(6)" = "EditRight" #Then
	 #Parameter(7) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(7))
		#If Not "#Parameter(6)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(6)" = "Object" OR "#Parameter(6)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(7))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right. 
// The Edit right can depend on the Read or Edit leading rights.
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(7))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(7)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(7)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(7)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(7)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(7)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(7)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(7)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
							AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(6)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(6)", ",") #Then
		IncorrectAccessKind: "#Parameter(6)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(6)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),") #Then
	
	 (
			ISNULL(#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(6),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(7)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(7)
		#ElsIf "#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(6)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(7)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(7))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(8) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 2
#If "#Parameter(9)" = "" AND "#Parameter(10)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(9)" = "Condition" OR "#Parameter(9)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(10) )
#ElsIf "#Parameter(9)" = "ReadRight" OR "#Parameter(9)" = "EditRight" #Then
	 #Parameter(10) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(10))
		#If Not "#Parameter(9)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(9)" = "Object" OR "#Parameter(9)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(10))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right. 
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(10))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(10)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(10)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(10)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(10)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(10)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(10)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(10)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(9)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(9),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(9)", ",") #Then
		IncorrectAccessKind: "#Parameter(9)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(9)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(9),") #Then
	
	 (
			ISNULL(#Parameter(10), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(9),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(9),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(10)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(10)
		#ElsIf "#Parameter(10)" = "T.Ref" #Then
			#If StrContains("#Parameter(9)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(9)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(10)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(10)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(10))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(11) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 3
#If "#Parameter(12)" = "" AND "#Parameter(13)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(12)" = "Condition" OR "#Parameter(12)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(13) )
#ElsIf "#Parameter(12)" = "ReadRight" OR "#Parameter(12)" = "EditRight" #Then
	 #Parameter(13) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(13))
		#If Not "#Parameter(12)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(12)" = "Object" OR "#Parameter(12)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(13))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(13))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(13)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(13)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(13)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(13)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(13)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(13)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(13)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(12)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(12)", ",") #Then
		IncorrectAccessKind: "#Parameter(12)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(12)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),") #Then
	
	 (
			ISNULL(#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(12),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(13)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(13)
		#ElsIf "#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(12)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(13)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(13))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(14) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 4
#If "#Parameter(15)" = "" AND "#Parameter(16)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(15)" = "Condition" OR "#Parameter(15)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(16) )
#ElsIf "#Parameter(15)" = "ReadRight" OR "#Parameter(15)" = "EditRight" #Then
	 #Parameter(16) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(16))
		#If Not "#Parameter(15)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(15)" = "Object" OR "#Parameter(15)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(16))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(16))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(16)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(16)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(16)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(16)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(16)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(16)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(16)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(15)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(15),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(15)", ",") #Then
		IncorrectAccessKind: "#Parameter(15)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(15)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(15),") #Then
	
	 (
			ISNULL(#Parameter(16), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(15),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(15),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(16)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(16)
		#ElsIf "#Parameter(16)" = "T.Ref" #Then
			#If StrContains("#Parameter(15)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(15)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(16)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(16)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(16))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(17) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 5
#If "#Parameter(18)" = "" AND "#Parameter(19)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(18)" = "Condition" OR "#Parameter(18)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(19) )
#ElsIf "#Parameter(18)" = "ReadRight" OR "#Parameter(18)" = "EditRight" #Then
	 #Parameter(19) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(19))
		#If Not "#Parameter(18)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(18)" = "Object" OR "#Parameter(18)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(19))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(19))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(19)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(19)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(19)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(19)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(19)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(19)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(19)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(18)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(18)", ",") #Then
		IncorrectAccessKind: "#Parameter(18)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(18)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),") #Then
	
	 (
			ISNULL(#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(18),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(19)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(19)
		#ElsIf "#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(18)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(19)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(19))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(20) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 6
#If "#Parameter(21)" = "" AND "#Parameter(22)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(21)" = "Condition" OR "#Parameter(21)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(22) )
#ElsIf "#Parameter(21)" = "ReadRight" OR "#Parameter(21)" = "EditRight" #Then
	 #Parameter(22) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(22))
		#If Not "#Parameter(21)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(21)" = "Object" OR "#Parameter(21)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(22))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(22))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(22)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(22)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(22)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(22)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(22)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(22)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(22)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(21)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(21),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(21)", ",") #Then
		IncorrectAccessKind: "#Parameter(21)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(21)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(21),") #Then
	
	 (
			ISNULL(#Parameter(22), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(21),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(21),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(22)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(22)
		#ElsIf "#Parameter(22)" = "T.Ref" #Then
			#If StrContains("#Parameter(21)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(21)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(22)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(22)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(22))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(23) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 7
#If "#Parameter(24)" = "" AND "#Parameter(25)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(24)" = "Condition" OR "#Parameter(24)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(25) )
#ElsIf "#Parameter(24)" = "ReadRight" OR "#Parameter(24)" = "EditRight" #Then
	 #Parameter(25) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(25))
		#If Not "#Parameter(24)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(24)" = "Object" OR "#Parameter(24)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(25))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(25))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(25)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(25)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(25)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(25)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(25)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(25)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(25)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND Not
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(24)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(24)", ",") #Then
		IncorrectAccessKind: "#Parameter(24)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(24)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),") #Then
	
	 (
			ISNULL(#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(24),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(25)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(25)
		#ElsIf "#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(24)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(25)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(25))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(26) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 8
#If "#Parameter(27)" = "" AND "#Parameter(28)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(27)" = "Condition" OR "#Parameter(27)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(28) )
#ElsIf "#Parameter(27)" = "ReadRight" OR "#Parameter(27)" = "EditRight" #Then
	 #Parameter(28) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(28))
		#If Not "#Parameter(27)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(27)" = "Object" OR "#Parameter(27)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(28))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(28))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(28)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(28)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(28)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(28)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(28)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(28)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(28)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(27)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(27),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(27)", ",") #Then
		IncorrectAccessKind: "#Parameter(27)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(27)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(27),") #Then
	
	 (
			ISNULL(#Parameter(28), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(27),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(27),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(28)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(28)
		#ElsIf "#Parameter(28)" = "T.Ref" #Then
			#If StrContains("#Parameter(27)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(27)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(28)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(28)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(28))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(29) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 9
#If "#Parameter(30)" = "" AND "#Parameter(31)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(30)" = "Condition" OR "#Parameter(30)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(31) )
#ElsIf "#Parameter(30)" = "ReadRight" OR "#Parameter(30)" = "EditRight" #Then
	 #Parameter(31) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(31))
		#If Not "#Parameter(30)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(30)" = "Object" OR "#Parameter(30)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(31))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(31))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(31)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(31)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(31)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(31)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(31)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(31)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(31)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(30)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(30)", ",") #Then
		IncorrectAccessKind: "#Parameter(30)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(30)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),") #Then
	
	 (
			ISNULL(#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(30),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(31)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(31)
		#ElsIf "#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(30)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(31)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(31))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(32) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 10
#If "#Parameter(33)" = "" AND "#Parameter(34)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(33)" = "Condition" OR "#Parameter(33)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(34) )
#ElsIf "#Parameter(33)" = "ReadRight" OR "#Parameter(33)" = "EditRight" #Then
	 #Parameter(34) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(34))
		#If Not "#Parameter(33)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(33)" = "Object" OR "#Parameter(33)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(34))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(34))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(34)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(34)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(34)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(34)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(34)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(34)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(34)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(33)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(33),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(33)", ",") #Then
		IncorrectAccessKind: "#Parameter(33)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(33)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(33),") #Then
	
	 (
			ISNULL(#Parameter(34), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(33),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(33),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(34)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(34)
		#ElsIf "#Parameter(34)" = "T.Ref" #Then
			#If StrContains("#Parameter(33)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(33)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(34)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(34)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(34))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(35) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 11
#If "#Parameter(36)" = "" AND "#Parameter(37)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(36)" = "Condition" OR "#Parameter(36)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(37) )
#ElsIf "#Parameter(36)" = "ReadRight" OR "#Parameter(36)" = "EditRight" #Then
	 #Parameter(37) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(37))
		#If Not "#Parameter(36)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(36)" = "Object" OR "#Parameter(36)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(37))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(37))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(37)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(37)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(37)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(37)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(37)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(37)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(37)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND Not(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(36)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(36),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error	
#If StrContains("#Parameter(36)", ",") #Then
		IncorrectAccessKind: "#Parameter(36)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(36)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(36),") #Then
	
	 (
			ISNULL(#Parameter(37), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(36),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(36),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(37)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NNOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(37)
		#ElsIf "#Parameter(37)" = "T.Ref" #Then
			#If StrContains("#Parameter(36)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(36)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(37)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(37)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(37))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(38) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 12
#If "#Parameter(39)" = "" AND "#Parameter(40)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(39)" = "Condition" OR "#Parameter(39)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(40) )
#ElsIf "#Parameter(39)" = "ReadRight" OR "#Parameter(39)" = "EditRight" #Then
	 #Parameter(40) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(40))
		#If Not "#Parameter(39)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(39)" = "Object" OR "#Parameter(39)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(40))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(40))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(40)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(40)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(40)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(40)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(40)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(40)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(40)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(39)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(39),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(39)", ",") #Then
		IncorrectAccessKind: "#Parameter(39)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(39)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(39),") #Then
	
	 (
			ISNULL(#Parameter(40), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(39),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(39),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(40)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(40)
		#ElsIf "#Parameter(40)" = "T.Ref" #Then
			#If StrContains("#Parameter(39)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(39)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(40)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(40)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(40))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(41) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 13
#If "#Parameter(42)" = "" AND "#Parameter(43)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(42)" = "Condition" OR "#Parameter(42)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(43) )
#ElsIf "#Parameter(42)" = "ReadRight" OR "#Parameter(42)" = "EditRight" #Then
	 #Parameter(43) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(43))
		#If Not "#Parameter(42)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(42)" = "Object" OR "#Parameter(42)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(43))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(43))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(43)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(43)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		Not
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(43)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(43)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(43)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(43)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND Not TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(43)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If Not &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(42)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(42),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(42)", ",") #Then
		IncorrectAccessKind: "#Parameter(42)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(42)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(42),") #Then
	
	 (
			ISNULL(#Parameter(43), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(42),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(42),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(43)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(43)
		#ElsIf "#Parameter(43)" = "T.Ref" #Then
			#If StrContains("#Parameter(42)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(42)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(43)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(43)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(43))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(44) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 14
#If "#Parameter(45)" = "" AND "#Parameter(46)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(45)" = "Condition" OR "#Parameter(45)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(46) )
#ElsIf "#Parameter(45)" = "ReadRight" OR "#Parameter(45)" = "EditRight" #Then
	 #Parameter(46) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(46))
		#If Not "#Parameter(45)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(45)" = "Object" OR "#Parameter(45)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(46))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(46))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(46)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(46)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(46)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(46)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(46)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(46)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(46)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(45)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(45),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(45)", ",") #Then
		IncorrectAccessKind: "#Parameter(45)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(45)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(45),") #Then
	
	 (
			ISNULL(#Parameter(46), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(45),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(45),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(46)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(46)
		#ElsIf "#Parameter(46)" = "T.Ref" #Then
			#If StrContains("#Parameter(45)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(45)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(46)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(46)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(46))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(47) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 15
#If "#Parameter(48)" = "" AND "#Parameter(49)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(48)" = "Condition" OR "#Parameter(48)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(49) )
#ElsIf "#Parameter(48)" = "ReadRight" OR "#Parameter(48)" = "EditRight" #Then
	 #Parameter(49) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(49))
		#If Not "#Parameter(48)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(48)" = "Object" OR "#Parameter(48)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(49))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(49))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(49)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(49)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(49)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(49)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(49)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(49)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(49)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(48)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(48),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(48)", ",") #Then
		IncorrectAccessKind: "#Parameter(48)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(48)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(48),") #Then
	
	 (
			ISNULL(#Parameter(49), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(48),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(48),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(49)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(49)
		#ElsIf "#Parameter(49)" = "T.Ref" #Then
			#If StrContains("#Parameter(48)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(48)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(49)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(49)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(49))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(50) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 16
#If "#Parameter(51)" = "" AND "#Parameter(52)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(51)" = "Condition" OR "#Parameter(51)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(52) )
#ElsIf "#Parameter(51)" = "ReadRight" OR "#Parameter(51)" = "EditRight" #Then
	 #Parameter(52) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(52))
		#If Not "#Parameter(51)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(51)" = "Object" OR "#Parameter(51)" = " " #Then
	(
		// Checking the leading table object right (right dependency)
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
			WHERE
				 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(52))
			#If #CurrentAccessRightName = "Read" #Then
// Checking the leading right for the Read right.
// The Read right can depend only on the Read right.
			#Else
// Checking the leading right for the Edit right.
// The Edit right can depend on the Read or Edit leading rights
				AND NOT
				(	 AccessGroupTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
					WHERE
						 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
					)
				)
			#EndIf
			)
		)
		// Checking the leading table object right restriction
		AND 
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						 VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(52))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnerTypes)
				)
		THEN
			(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(52)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = #Parameter(52)
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						 #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						 #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		 TRUE IN // Not all checks are disabled
		 (
				SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
				FROM InformationRegister.AccessValueSets AS SetNumbers
				WHERE
					 SetNumbers.Object = #Parameter(52)
				#If #CurrentAccessRightName = "Read" #Then
					// The Read right can depend only on the Read right
					AND SetNumbers.Read = TRUE
				#Else
					// The Edit right can depend on Read or Edit leading rights
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
							WHERE
								 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
							)
						THEN SetNumbers.Read
						ELSE SetNumbers.Update
					 END
				#EndIf
					AND
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(52)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		 ) AND NOT
	#Else
		 (
	#EndIf
		 TRUE IN
		 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Object = #Parameter(52)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				AND SetNumbers.Read = TRUE
			#Else
				// The Edit right can depend on Read or Edit leading rights
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightDependencies AS AccessRightDependencies
						WHERE
							 AccessRightDependencies.SubordinateTable = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
						)
					THEN SetNumbers.Read
					ELSE SetNumbers.Update
				 END
			#EndIf
				AND
			 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks in the current set are disabled
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
					FROM InformationRegister.AccessValueSets AS ValueSets
					WHERE
						 ValueSets.Object = #Parameter(52)
						AND ValueSets.SetNumber = SetNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings
								FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								WHERE
									 DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			 #EndIf
				 NOT FALSE IN // All checks are successful
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
				FROM InformationRegister.AccessValueSets AS ValueSets
				WHERE
					 ValueSets.Object = #Parameter(52)
					AND ValueSets.SetNumber = SetNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			 #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			 #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefTypes
							WHERE
								 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
							)
					THEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueSets.AccessValue
							WHERE
								 DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValueGroups AS AccessValueGroups
							WHERE
								 AccessValueGroups.AccessValue = ValueSets.AccessValue
								AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
								INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
								ON
									 ValueGroups.AccessValue = ValueSets.AccessValue
									AND DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
								
								LEFT JOIN InformationRegister.AccessGroupValues AS Values
								ON
									 Values.AccessGroup = AccessGroups.Ref
									AND Values.AccessValue = ValueGroups.AccessValueGroup
							WHERE
								ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
							)
				#If Not #CurrentAccessRightName = "Read"
				 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true single-string set of values
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access right to the AccessValues table
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// The Read right can depend only on the Read right
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
						WHERE
							 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnerTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								 SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
									THEN ValueSets.Adjustment
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
							ON
								 UserGroupContent.User = &amp;AuthorizedUser
								AND UserGroupContent.UserGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		 )
		 )
	#If Not &amp;RightsSettingsOwnerTypes = "" #Then
		END
	#EndIf
	)

#ElsIf "#Parameter(51)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(51),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(51)", ",") #Then
		IncorrectAccessKind: "#Parameter(51)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(51)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(51),") #Then
	
	 (
			ISNULL(#Parameter(52), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(51),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(51),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(52)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(52)
		#ElsIf "#Parameter(52)" = "T.Ref" #Then
			#If StrContains("#Parameter(51)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(51)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(52)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(52)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(52))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	TRUE
#EndIf

	#Parameter(53) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

 )
)
#EndIf


 )
)
#EndIf

</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValueSets</name>
		<condition>// ByValueSets(Table, -, Modifier, SetsOwner).
// Parameter #: 1, 2, 3, 4.
// Read as: "access restriction by value sets".
// Parameters:
// Table - The current table name, for example, Document.ProductAndServiceReceipt.
// Modifier - changes the template.
// Modifier 1 - the string DontLimitAccessToGroups specifies that groups of the hierarchical catalog must be selected unconditionally.
// Modifier 2 - the AdvancedOR string enables
// advanced check for restrictions (for example
// ByCompanies or ByAccounts) where access kind setting option
// in access groups "All allowed, none prohibited" is considered as "Access kind is not used".
// If this modifier is not used, the check
// result is True and therefore the final result is also
// True provided that "All allowed, none prohibited" option is set for at least one access kind (either ByCompanies or ByAccounts).
// Modifier is intended for use only when checking access value sets.
// You can combine modifiers
// as follows: "DontLimitAccessToGroups", "AdvancedOR", "DontLimitAccessToGroups,AdvancedOR".
// No other modifiers are available in this version of the template.
// SetsOwner - name of the field containing
// the reference to access value sets owner object in the AccessValueSets information register.
// If the field name is not set, it
// is considered that the access value sets owner object, which has a tabular section &lt;Table&gt;, is checked. AccessValueSets.
// This tabular section is used when Right = "Edit".
// Tabular section is exactly the same as InformationRegisterAccessValueSets
// without Object dimension and attributes
// Specify Reference for document journals
//
// Example1: ByValueSets("Document.MoneyAdjustment", "", "", "")
// Example2: ByValueSets("Document.ProductAndServiceReceipt", "", "", "")
// Example3: ByValueSets("DocumentJournal.WarehouseDocuments", "", "", "Ref")
// Example4: ByValueSets("Catalog.EmailAttachments", "", "", "Owner")

// Validating the Right parameter
#If Not ("#Parameter(2)" = "Read" OR "#Parameter(2)" = "Insert" OR
 "#Parameter(2)" = "Update" OR "#Parameter(2)" = "Delete" OR "#Parameter(2)" = "")
 OR #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)" = "Read"
 OR #CurrentAccessRightName = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is invalid, a string is inserted to raise an access restriction assembly error
 InvalidRight: #Parameter(2)
#EndIf

// Validating the Modifier parameter TableName
#If "#Parameter(1)" &lt;&gt; #CurrentTypeName #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter
#If Not ( "#Parameter(3)" = "DontLimitAccessToGroups"
 OR "#Parameter(3)" = "AdvancedOR"
 OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR"
 OR "#Parameter(3)" = "") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	InvalidModifier: #Parameter(3)
#EndIf

// InvalidRight Parameter EndIf The overall checking if access restriction on record level are used
#If &amp;UseRecordLevelSecurity #Then

T WHERE // T is the current table alias (intentionally shortened in order to minimize the number of characters in the text of the condition parameter in the query language)

// Unconditional selection of folders in a hierarchical metadata object (if required)
#If "#Parameter(3)" = "DontLimitAccessToGroups" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
	T.IsFolder OR
#EndIf

TRUE IN
(	// Checking user rights for the entire current table.
	// Rights for tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
		Catalog.MetadataObjectIDs AS CurrentTableProperties
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			 (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupTables AS AccessGroupTables
					WHERE
						 AccessGroupTables.Table = CurrentTableProperties.Ref
						AND AccessGroupTables.AccessGroup = AccessGroups.Ref
					#If Not #CurrentAccessRightName = "Read" #Then
						AND AccessGroupTables.Update
					#EndIf
			 )
			AND AccessGroups.Ref IN
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
					ON
						 UserGroupContent.User = &amp;AuthorizedUser
						AND UserGroupContent.UserGroup = AccessGroupsUsers.User
			 )
	WHERE
#If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
 Not
 (
 TRUE IN // Not all checks are disabled
 (
			SELECT TOP 1 TRUE // Selecting the first set where a check is not disabled
		#If #CurrentAccessRightName = "Read" #Then
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
			#If "#Parameter(4)" = "" #Then
				 SetNumbers.Object = T.Ref
			#Else
				 SetNumbers.Object = T.#Parameter(4)
			#EndIf
		#Else
			FROM #Parameter(1).AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Ref = T.Ref
		#EndIf
			#If #CurrentAccessRightName = "Read" #Then
				AND SetNumbers.Read
			#Else
				AND SetNumbers.Update
			#EndIf
				AND 
	TRUE IN // Not all checks in the current set are disabled
	(
		SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValueSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			 ValueSets.Object = T.Ref
		#Else
			 ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValueSets AS ValueSets
		WHERE
			 ValueSets.Ref = T.Ref
	#EndIf
			AND ValueSets.SetNumber = SetNumbers.SetNumber
			AND NOT TRUE IN
				(
					SELECT TOP 1 TRUE // Searching for access restriction settings
					FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
					WHERE
						 DefaultValues.AccessGroup = AccessGroups.Ref
						AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
						AND DefaultValues.NoSettings = TRUE
				)
	)
 ) AND NOT
#Else
 (
#EndIf
 TRUE IN
 (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed
		#If #CurrentAccessRightName = "Read" #Then
			FROM InformationRegister.AccessValueSets AS SetNumbers
			WHERE
			#If "#Parameter(4)" = "" #Then
				 SetNumbers.Object = T.Ref
			#Else
				 SetNumbers.Object = T.#Parameter(4)
			#EndIf
		#Else
			FROM #Parameter(1).AccessValueSets AS SetNumbers
			WHERE
				 SetNumbers.Ref = T.Ref
		#EndIf
			#If #CurrentAccessRightName = "Read" #Then
				AND SetNumbers.Read
			#Else
				AND SetNumbers.Update
			#EndIf
				AND
 #If "#Parameter(3)" = "AdvancedOR" OR "#Parameter(3)" = "DontLimitAccessToGroups,AdvancedOR" #Then
	TRUE IN // Not all checks in the current set are disabled
	(
		SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValueSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			 ValueSets.Object = T.Ref
		#Else
			 ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValueSets AS ValueSets
		WHERE
			 ValueSets.Ref = T.Ref
	#EndIf
			AND ValueSets.SetNumber = SetNumbers.SetNumber
			AND Not TRUE IN
				(
					SELECT TOP 1 TRUE // Searching for access restriction settings
					FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
					WHERE
						 DefaultValues.AccessGroup = AccessGroups.Ref
						AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
						AND DefaultValues.NoSettings = TRUE
				)
	) AND
 #EndIf
	Not FALSE IN // All checks are successful
	(
		SELECT TOP 1 FALSE // Selecting the first access value that is not allowed
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValueSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			 ValueSets.Object = T.Ref
		#Else
			 ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValueSets AS ValueSets
		WHERE
			 ValueSets.Ref = T.Ref
	#EndIf
			AND ValueSets.SetNumber = SetNumbers.SetNumber
			AND NOT
			CASE
		#If #CurrentAccessRightName = "Read" #Then
		 #If Not &amp;DisabledAccessKinds = "All" #Then
			WHEN ValueSets.ValueWithoutGroups
			THEN
				TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
						LEFT JOIN InformationRegister.AccessGroupValues AS Values
						ON
							 Values.AccessGroup = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
					WHERE
						 DefaultValues.AccessGroup = AccessGroups.Ref
						AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
						AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
					)
		 #EndIf
			WHEN ValueSets.StandardValue
		#Else
			WHEN
				TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
					WHERE
						VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
				)
		#EndIf
		#If &amp;DisabledAccessKinds = "All" #Then
			THEN
				TRUE
		#Else
			THEN
			#If Not #CurrentAccessRightName = "Read"
			 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
			 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
				CASE
			#EndIf
			#If Not #CurrentAccessRightName = "Read" #Then
				WHEN
					NOT TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM Catalog.MetadataObjectIDs AS RefTypes
						WHERE
							 VALUETYPE(RefTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
							AND RefTypes.EmptyRefValue IN (&amp;AccessValueTypesWithGroups)
						)
				THEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
						WHERE
							 DefaultValues.AccessGroup = AccessGroups.Ref
							AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							AND ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			#EndIf
			#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
			 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
				WHEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessValueGroups AS AccessValueGroups
						WHERE
							 AccessValueGroups.AccessValue = ValueSets.AccessValue
							AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
						)
				THEN
					TRUE
			#EndIf
			#If Not #CurrentAccessRightName = "Read"
			 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
			 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
				ELSE
			#EndIf
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
							INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
							ON
								 ValueGroups.AccessValue = ValueSets.AccessValue
								AND DefaultValues.AccessGroup = AccessGroups.Ref
								AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(ValueSets.AccessValue)
							
							LEFT JOIN InformationRegister.AccessGroupValues AS Values
							ON
								 Values.AccessGroup = AccessGroups.Ref
								AND Values.AccessValue = ValueGroups.AccessValueGroup
						WHERE
							ISNULL(Values.ValueIsAllowed, DefaultValues.AllAllowed)
						)
			#If Not #CurrentAccessRightName = "Read"
			 OR Not StrContains(&amp;DisabledAccessKinds, ",Users,")
			 OR Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
				END
			#EndIf
		#EndIf
			// Checking a definitely false or true single-string set of values
			WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
			THEN TRUE
			WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
			THEN FALSE
			// Checking user access right to the AccessValues table
			WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
		#If #CurrentAccessRightName = "Read" #Then
			// The Read right can depend only on the Read right
			THEN TRUE IN
				(	SELECT TOP 1 TRUE
					FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
					WHERE
						 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
						AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
				)
		#Else
			THEN TRUE IN
				(	SELECT TOP 1 TRUE
					FROM InformationRegister.AccessGroupTables AS AccessGroupTablesObjectRightCheck
					WHERE
						 AccessGroupTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
						AND AccessGroupTablesObjectRightCheck.Table = ValueSets.AccessValue
						AND NOT(ValueSets.Adjustment &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
								AND AccessGroupTablesObjectRightCheck.Update = FALSE)
				)
		#EndIf
		#If Not &amp;RightsSettingsOwnerTypes = "" #Then
			ELSE
				(
				TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = ValueSets.AccessValue
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
							AND RightsSettings.Table = CASE
								WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
								THEN ValueSets.Adjustment
								ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking whether the right is denied to the user or to any group that includes the user
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							 SettingsInheritance.Object = ValueSets.AccessValue
							AND RightsSettings.Object = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
							AND RightsSettings.Table = CASE
								WHEN ValueSets.Adjustment IN (&amp;IDsOfTablesWithSpecificRightSettings)
								THEN ValueSets.Adjustment
								ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
						#EndIf
						INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
						ON
							 UserGroupContent.User = &amp;AuthorizedUser
							AND UserGroupContent.UserGroup = RightsSettings.User
					)
				)
		#Else
			ELSE
				FALSE
		#EndIf
			END
	) // NOT FALSE IN
 )
 )
)
#EndIf

 )
 )
)
#EndIf

</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValuesEx</name>
		<condition>// ByValuesEx(Table, -, Modifier, JoinedTables, B, A1,F1,B1, A2,F2,B2,..., A(n), F(n), B(n)).
// Parameter #: 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,...,3+n*3,4+n*3,5+n*3.
// Read as: "access restriction by values advanced"
// Parameters:
// Table - The current table name, for example, Document.ProductAndServiceReceipt.
// Modifier - changes the template.
// Modifier 1 - the string DontLimitAccessToGroups specifies that groups of the hierarchical catalog should be selected without conditions
// No other modifiers are available in this version of the template.
// JoinedTables - the text of command used to join the additional tables in the query language such as "INNER JOIN Document.AdvanceReport.PaymentToVendor AS T1 On T.Link = T1.Ref".
// Joining allows to define fields of PaymentToVendor table as
// fields of main table, in order to check values of those fields as if they were main table field values.
// The user should keep in mind that when strings multiply
// as a result of the joining, it is enough for any string to satisfy the check condition, so the string check results are joined by "OR".
// B - Leading brackets "(".
// A(n) - Access kind - name of access kind, for example, "Companies". For composite type fields, you
// can improve performance by specifying multiple names,
// for example, "Companies,IndividualGroups", rather than use several parameter blocks with the same field name.
// You can use special access kinds such as "Condition", "RightsSettings", "ReadRight", "EditRight" only separately.
// When A(n) = "Condition" (or ""), then P(n) contains a condition string in the language of
// queries, for example, "T.Author = &amp;AuthorizedUser", "VALUETYPE(T.Owner) = TYPE(Catalog.Companies)", where T - alias of current table.
// When A(n) = "ReadRight" Or "EditRight", rights for the T.P(n) value table are checked.
// P(n) - The field of a checked value
// with an alias, for example, "T.Company", except for cases when A(n) = "Condition" or "".
// O(n) - Logical operations "AND", "OR" in combination with brackets "(", ")".
// Note: you can increase the maximum number of field values checked
// at the same time by changing the template, but you must specify all template parameters, i.e. include empty rows when the number of fields is below maximum.
// The template has the following structure:
// &lt;Common part of conditions&gt; &lt;Condition by parameter group 1&gt; AND/OR &lt;Condition by parameter group 2&gt; AND/OR ... &lt;Condition by the parameter group(n)&gt;
// Example:
// ByValuesEx("Document.ProductTransfer", "", "",
// "",
// "",
// "Companies","T.Company","And(",
// "Warehouses","T.SourceWarehouse","OR",
// "Warehouses","T.DestinationWarehouse",")", "","","", ...)

// Validating the Right parameter
#If Not ("#Parameter(2)" = "Read" OR "#Parameter(2)" = "Insert" OR
 "#Parameter(2)" = "Update" OR "#Parameter(2)" = "Delete" OR "#Parameter(2)" = "")
 OR #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)" = "Read"
 OR #CurrentAccessRightName = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
 // When the parameter is invalid, a string is inserted to raise an access restriction assembly error
 InvalidRight: #Parameter(2)
#EndIf

// Validating the Modifier parameter TableName
#If "#Parameter(1)" &lt;&gt; #CurrentTypeName #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter
#If Not ("#Parameter(3)" = "DontLimitAccessToGroups" OR "#Parameter(3)" = "") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	InvalidModifier: #Parameter(3)
#EndIf

// Making the general check whether access restrictions are
// used at the record level. Checking whether at least one restriction from the specified access kinds is used.
#If &amp;UseRecordLevelSecurity
 AND Not (True
 AND ("#Parameter(6)" = "" AND "#Parameter(7)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(6),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),"))
 AND ("#Parameter(9)" = "" AND "#Parameter(10)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(9),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(9),"))
 AND ("#Parameter(12)" = "" AND "#Parameter(13)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(12),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),"))
 AND ("#Parameter(15)" = "" AND "#Parameter(16)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(15),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(15),"))
 AND ("#Parameter(18)" = "" AND "#Parameter(19)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(18),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),"))
 AND ("#Parameter(21)" = "" AND "#Parameter(22)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(21),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(21),"))
 AND ("#Parameter(24)" = "" AND "#Parameter(25)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(24),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),"))
 AND ("#Parameter(27)" = "" AND "#Parameter(28)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(27),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(27),"))
 AND ("#Parameter(30)" = "" AND "#Parameter(31)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(30),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),"))
 AND ("#Parameter(33)" = "" AND "#Parameter(34)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(33),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(33),"))
 AND ("#Parameter(36)" = "" AND "#Parameter(37)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(36),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(36),"))
 AND ("#Parameter(39)" = "" AND "#Parameter(40)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(39),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(39),"))
 AND ("#Parameter(42)" = "" AND "#Parameter(43)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(42),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(42),"))
 AND ("#Parameter(45)" = "" AND "#Parameter(46)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(45),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(45),"))
 AND ("#Parameter(48)" = "" AND "#Parameter(49)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(48),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(48),"))
 AND ("#Parameter(51)" = "" AND "#Parameter(52)" = ""
 OR &amp;DisabledAccessKinds = "All"
 AND Not StrContains(",Condition,,RightSettings,Object, ,ReadRight,EditRight,", ",#Parameter(51),")
 OR StrContains(&amp;DisabledAccessKinds, ",#Parameter(51),"))
 ) #Then

T FROM T // T is the current table alias (intentionally shortened in order to minimize the number of characters in the text of the condition parameter in the query language)

// Tables joined to the row of the current table T that is being checked
#Parameter(4)

WHERE

// Unconditional selection of folders in a hierarchical metadata object (if required)
#If "#Parameter(3)" = "DontLimitAccessToGroups" #Then
	T.IsFolder OR
#EndIf

TRUE IN
(	// Checking user rights for the entire current table.
	// Rights for tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
		Catalog.MetadataObjectIDs AS CurrentTableProperties
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			 CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			 (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupTables AS AccessGroupTables
					WHERE
						 AccessGroupTables.Table = CurrentTableProperties.Ref
						AND AccessGroupTables.AccessGroup = AccessGroups.Ref
					#If Not #CurrentAccessRightName = "Read" #Then
						AND AccessGroupTables.Update
					#EndIf
			 )
			AND AccessGroups.Ref IN
			 (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
					ON
						 UserGroupContent.User = &amp;AuthorizedUser
						AND UserGroupContent.UserGroup = AccessGroupsUsers.User
			 )
	WHERE
 ( // Searching for values of the specified fields in the allowed values of access groups (users)

	#Parameter(5) // [([(][(]...] 0-n opening brackets.

//// Checking the field value of parameter group 1
#If "#Parameter(6)" = "Condition" OR "#Parameter(6)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	( #Parameter(7) )
#ElsIf "#Parameter(6)" = "ReadRight" OR "#Parameter(6)" = "EditRight" #Then
	 #Parameter(7) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(7))
		#If Not "#Parameter(6)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(6)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(6),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(6)", ",") #Then
		IncorrectAccessKind: "#Parameter(6)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(6)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),") #Then
	
	 (
			ISNULL(#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(6),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(7)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(7)
		#ElsIf "#Parameter(7)" = "T.Ref" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(6)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
				 	 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(7)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(7))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(8) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 2
#If "#Parameter(9)" = "" AND "#Parameter(10)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(9)" = "Condition" OR "#Parameter(9)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(10) )
#ElsIf "#Parameter(9)" = "ReadRight" OR "#Parameter(9)" = "EditRight" #Then
	 #Parameter(10) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(10))
		#If Not "#Parameter(9)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(9)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(9),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(9)", ",") #Then
		IncorrectAccessKind: "#Parameter(9)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(9)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(9),") #Then
	
	 (
			ISNULL(#Parameter(10), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(9),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(9),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(10)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(10)
		#ElsIf "#Parameter(10)" = "T.Ref" #Then
			#If StrContains("#Parameter(9)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(9)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(10)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(10)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(10))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(11) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 3
#If "#Parameter(12)" = "" AND "#Parameter(13)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(12)" = "Condition" OR "#Parameter(12)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(13) )
#ElsIf "#Parameter(12)" = "ReadRight" OR "#Parameter(12)" = "EditRight" #Then
	 #Parameter(13) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(13))
		#If Not "#Parameter(12)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(12)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(12),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(12)", ",") #Then
		IncorrectAccessKind: "#Parameter(12)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(12)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),") #Then
	
	 (
			ISNULL(#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(12),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(13)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(13)
		#ElsIf "#Parameter(13)" = "T.Ref" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(12)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(13)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(13))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(14) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 4
#If "#Parameter(15)" = "" AND "#Parameter(16)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(15)" = "Condition" OR "#Parameter(15)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(16) )
#ElsIf "#Parameter(15)" = "ReadRight" OR "#Parameter(15)" = "EditRight" #Then
	 #Parameter(16) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(16))
		#If Not "#Parameter(15)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(15)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(15),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(15)", ",") #Then
		IncorrectAccessKind: "#Parameter(15)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(15)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(15),") #Then
	
	 (
			ISNULL(#Parameter(16), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(15),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(15),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(16)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(16)
		#ElsIf "#Parameter(16)" = "T.Ref" #Then
			#If StrContains("#Parameter(15)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(15)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
				 	 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(16)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(16)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(16))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(17) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 5
#If "#Parameter(18)" = "" AND "#Parameter(19)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(18)" = "Condition" OR "#Parameter(18)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(19) )
#ElsIf "#Parameter(18)" = "ReadRight" OR "#Parameter(18)" = "EditRight" #Then
	 #Parameter(19) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(19))
		#If Not "#Parameter(18)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(18)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(18),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(18)", ",") #Then
		IncorrectAccessKind: "#Parameter(18)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(18)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),") #Then
	
	 (
			ISNULL(#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(18),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(19)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(19)
		#ElsIf "#Parameter(19)" = "T.Ref" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(18)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(19)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(19))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(20) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 6
#If "#Parameter(21)" = "" AND "#Parameter(22)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(21)" = "Condition" OR "#Parameter(21)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(22) )
#ElsIf "#Parameter(21)" = "ReadRight" OR "#Parameter(21)" = "EditRight" #Then
	 #Parameter(22) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(22))
		#If Not "#Parameter(21)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(21)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(21),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(21)", ",") #Then
		IncorrectAccessKind: "#Parameter(21)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(21)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(21),") #Then
	
	 (
			ISNULL(#Parameter(22), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(21),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(21),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(22)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(22)
		#ElsIf "#Parameter(22)" = "T.Ref" #Then
			#If StrContains("#Parameter(21)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(21)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(22)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(22)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(22))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(23) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 7
#If "#Parameter(24)" = "" AND "#Parameter(25)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(24)" = "Condition" OR "#Parameter(24)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(25) )
#ElsIf "#Parameter(24)" = "ReadRight" OR "#Parameter(24)" = "EditRight" #Then
	 #Parameter(25) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(25))
		#If Not "#Parameter(24)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(24)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(24),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(24)", ",") #Then
		IncorrectAccessKind: "#Parameter(24)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(24)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),") #Then
	
	 (
			ISNULL(#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(24),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(25)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(25)
		#ElsIf "#Parameter(25)" = "T.Ref" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(24)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(25)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(25))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(26) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 8
#If "#Parameter(27)" = "" AND "#Parameter(28)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(27)" = "Condition" OR "#Parameter(27)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(28) )
#ElsIf "#Parameter(27)" = "ReadRight" OR "#Parameter(27)" = "EditRight" #Then
	 #Parameter(28) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(28))
		#If Not "#Parameter(27)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(27)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(27),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(27)", ",") #Then
		IncorrectAccessKind: "#Parameter(27)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(27)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(27),") #Then
	
	 (
			ISNULL(#Parameter(28), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(27),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(27),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(28)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(28)
		#ElsIf "#Parameter(28)" = "T.Ref" #Then
			#If StrContains("#Parameter(27)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(27)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(28)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(28)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(28))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(29) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 9
#If "#Parameter(30)" = "" AND "#Parameter(31)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(30)" = "Condition" OR "#Parameter(30)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(31) )
#ElsIf "#Parameter(30)" = "ReadRight" OR "#Parameter(30)" = "EditRight" #Then
	 #Parameter(31) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(31))
		#If Not "#Parameter(30)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(30)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(30),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(30)", ",") #Then
		IncorrectAccessKind: "#Parameter(30)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(30)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),") #Then
	
	 (
			ISNULL(#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(30),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(31)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(31)
		#ElsIf "#Parameter(31)" = "T.Ref" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(30)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(31)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(31))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(32) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 10
#If "#Parameter(33)" = "" AND "#Parameter(34)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(33)" = "Condition" OR "#Parameter(33)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(34) )
#ElsIf "#Parameter(33)" = "ReadRight" OR "#Parameter(33)" = "EditRight" #Then
	 #Parameter(34) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(34))
		#If Not "#Parameter(33)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(33)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(33),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(33)", ",") #Then
		IncorrectAccessKind: "#Parameter(33)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(33)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(33),") #Then
	
	 (
			ISNULL(#Parameter(34), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(33),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(33),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(34)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(34)
		#ElsIf "#Parameter(34)" = "T.Ref" #Then
			#If StrContains("#Parameter(33)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(33)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(34)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(34)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(34))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(35) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 11
#If "#Parameter(36)" = "" AND "#Parameter(37)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(36)" = "Condition" OR "#Parameter(36)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(37) )
#ElsIf "#Parameter(36)" = "ReadRight" OR "#Parameter(36)" = "EditRight" #Then
	 #Parameter(37) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(37))
		#If Not "#Parameter(36)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(36)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(36),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(36)", ",") #Then
		IncorrectAccessKind: "#Parameter(36)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(36)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(36),") #Then
	
	 (
			ISNULL(#Parameter(37), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(36),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(36),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(37)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(37)
		#ElsIf "#Parameter(37)" = "T.Ref" #Then
			#If StrContains("#Parameter(36)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(36)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(37)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(37)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(37))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(38) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 12
#If "#Parameter(39)" = "" AND "#Parameter(40)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(39)" = "Condition" OR "#Parameter(39)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(40) )
#ElsIf "#Parameter(39)" = "ReadRight" OR "#Parameter(39)" = "EditRight" #Then
	 #Parameter(40) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(40))
		#If Not "#Parameter(39)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(39)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(39),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(39)", ",") #Then
		IncorrectAccessKind: "#Parameter(39)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(39)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(39),") #Then
	
	 (
			ISNULL(#Parameter(40), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(39),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(39),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(40)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(40)
		#ElsIf "#Parameter(40)" = "T.Ref" #Then
			#If StrContains("#Parameter(39)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(39)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(40)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(40)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(40))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(41) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 13
#If "#Parameter(42)" = "" AND "#Parameter(43)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(42)" = "Condition" OR "#Parameter(42)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(43) )
#ElsIf "#Parameter(42)" = "ReadRight" OR "#Parameter(42)" = "EditRight" #Then
	 #Parameter(43) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(43))
		#If Not "#Parameter(42)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(42)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(42),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(42)", ",") #Then
		IncorrectAccessKind: "#Parameter(42)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(42)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(42),") #Then
	
	 (
			ISNULL(#Parameter(43), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(42),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(42),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(43)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(43)
		#ElsIf "#Parameter(43)" = "T.Ref" #Then
			#If StrContains("#Parameter(42)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(42)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(43)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(43)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(43))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(44) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 14
#If "#Parameter(45)" = "" AND "#Parameter(46)" = "" #Then
	// Parameter group is not used.
#ElsIf "#Parameter(45)" = "Condition" OR "#Parameter(45)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(46) )
#ElsIf "#Parameter(45)" = "ReadRight" OR "#Parameter(45)" = "EditRight" #Then
	 #Parameter(46) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(46))
		#If Not "#Parameter(45)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(45)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(45),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(45)", ",") #Then
		IncorrectAccessKind: "#Parameter(45)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(45)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(45),") #Then
	
	 (
			ISNULL(#Parameter(46), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(45),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(45),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(46)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(46)
		#ElsIf "#Parameter(46)" = "T.Ref" #Then
			#If StrContains("#Parameter(45)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(45)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(46)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(46)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(46))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(47) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 15
#If "#Parameter(48)" = "" AND "#Parameter(49)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(48)" = "Condition" OR "#Parameter(48)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(49) )
#ElsIf "#Parameter(48)" = "ReadRight" OR "#Parameter(48)" = "EditRight" #Then
	 #Parameter(49) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(49))
		#If Not "#Parameter(48)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(48)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(48),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(48)", ",") #Then
		IncorrectAccessKind: "#Parameter(48)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(48)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(48),") #Then
	
	 (
			ISNULL(#Parameter(49), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(48),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(48),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(49)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(49)
		#ElsIf "#Parameter(49)" = "T.Ref" #Then
			#If StrContains("#Parameter(48)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(48)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(49)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(49)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(49))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(50) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

//// Checking the field value of parameter group 16
#If "#Parameter(51)" = "" AND "#Parameter(52)" = "" #Then
	// Parameter group is not used
#ElsIf "#Parameter(51)" = "Condition" OR "#Parameter(51)" = "" #Then
	// When the access kind name is "Condition" (or ""), a condition is specified instead of the field name
	 ( #Parameter(52) )
#ElsIf "#Parameter(51)" = "ReadRight" OR "#Parameter(51)" = "EditRight" #Then
	 #Parameter(52) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking the user right for the Values table specified in the field
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupTables AS AccessGroupTablesRightCheck
		WHERE
			 AccessGroupTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupTablesRightCheck.TableType) = VALUETYPE(#Parameter(52))
		#If Not "#Parameter(51)" = "ReadRight" #Then
			AND AccessGroupTablesRightCheck.Update
		#EndIf
	 )
#ElsIf "#Parameter(51)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking whether the right is granted to the user or to any group that includes the user
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			) AND NOT FALSE IN // Checking whether the right is denied to the user or any group that includes the user
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					 SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				 #If StrContains(&amp;TablesWithIndividualRightSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				 #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				 #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupContent AS UserGroupContent
				ON
					 UserGroupContent.User = &amp;AuthorizedUser
					AND UserGroupContent.UserGroup = RightsSettings.User
			)
	 )
#ElsIf Not StrContains(&amp;AllAccessKindsExceptSpecial, ",#Parameter(51),") #Then
	// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
	#If StrContains("#Parameter(51)", ",") #Then
		IncorrectAccessKind: "#Parameter(51)" - "List of access kind names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(51)" - "Access kind name is not found"
	#EndIf
#ElsIf &amp;DisabledAccessKinds &lt;&gt; "All"
 AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(51),") #Then
	
	 (
			ISNULL(#Parameter(52), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,") AND StrContains(",#Parameter(51),", ",Users,"))
		 OR (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(51),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValueGroups AS AccessValueGroups
				WHERE
					 AccessValueGroups.AccessValue = #Parameter(52)
					AND AccessValueGroups.AccessValueGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(52)
		#ElsIf "#Parameter(52)" = "T.Ref" #Then
			#If StrContains("#Parameter(51)", ",") #Then
				// When the parameter is invalid, a string is inserted to raise an access restriction assembly error
				IncorrectAccessKind: "#Parameter(51)" - "Only one access kind can be specified during the access value table check"
			#ElsIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
				WHERE
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref = #Parameter(52)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupValues AS Values
					INNER JOIN InformationRegister.AccessValueGroups AS ValueGroups
				ON
					 Values.AccessGroup = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessValueGroup
					AND ValueGroups.AccessValue = #Parameter(52)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupValues AS DefaultValues
				WHERE
				 DefaultValues.AccessGroup = AccessGroups.Ref
				 AND VALUETYPE(DefaultValues.AccessValueType) = VALUETYPE(#Parameter(52))
				 AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	TRUE
#EndIf

	#Parameter(53) // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without brackets.

 )
)
#EndIf


 )
)
#EndIf

</condition>
	</restrictionTemplate>
</Rights>